group Python;

packageDeclaration(name) ::=<<

    #packageDeclaration to do

>> 

qualifiedName(i, is) ::=<<

    #qualifiedName to do

>> 

multiIDImportDeclaration(i1, ids) ::=<<
#import Statement commented out due to uncertainty
#from <i1> import <ids; separator=".">

>> 

singleIDImportDeclaration(i) ::=<<
#import Statement commented out due to uncertainty
#from <i> import *
>> 

classOrInterfaceType(i, typeArguments, ids, tas) ::=<<

    #classOrInterfaceType to do

>>

typeClassOrInterfaceType(classOrInterfaceType) ::=<<

    #typeClassOrInterfaceType to do

>> 

normalParameterDecl(variableModifiers, type, i) ::=<<
<i>
>> 

int() ::=<<
    #int to do
>> 

typePrimitiveType(primitiveType) ::=<<

    #typePrimitiveType to do

>> 

formalParameterDeclsNormal(n, ns) ::=<<
<n><if (ns)>,<ns; separator=","><endif>
>>

formalParameters(formalParameterDecls) ::=<<
<formalParameterDecls>
>>

identifierPrimary(i, is, identifierSuffix) ::=<<
<i><is><identifierSuffix>
>>

primaryExpression(p, selectors, symbol) ::=<<
<p><selectors><symbols>
>> 

multiplicativeExpression(u, symbols, us) ::=<<
<u><symbols><us>
>>

additiveExpression(m1, symbols, ms) ::=<<
<m1><symbols><ms>
>> 

shiftExpression(a1, s, a) ::=<<
<a1><s><a>
>>

less(x) ::=<<
 <x>
>>

test(i) ::=<<
 <i>
>>

relationalExpression(shiftExpression, relationalOp, shiftExpressions) ::=<<
<shiftExpression><relationalOp><shiftExpressions>
>>

instanceOfExpression(relationalExpression, type) ::=<<
<relationalExpression>
>>

equalityExpression(i, symbols, is) ::=<<
<i><symbols><is>
>>

andExpression(e, es) ::=<<
<e><es>
>>

conditionalExpression(conditionalOrExpression, expression) ::=<<
<conditionalOrExpression><expression>
>> 


conditionalOrExpression(conditionalAndExpression, cs) ::=<<
<conditionalAndExpression><cs>
>> 

conditionalAndExpression(i, is) ::=<<
<i><is>
>> 

inclusiveOrExpression(e, es) ::=<<
<e><es>
>> 

exclusiveOrExpression(a, as) ::=<<
<a><as>
>> 

expression(conditionalExpression, assignmentOperator, expression) ::=<<
<conditionalExpression><assignmentOperator><expression>
>>

parExpression(expression) ::=<<
<expression>
>>

expressionStatement(expr) ::=<<
<expr>
>> 

block(b) ::=<<
<b; separator="\n">
>> 

ifStatement(parExpression,s1, s2) ::=<<
if <parExpression>:
    <s1>
else:
    <s2>
>>

whilestatement(parExpression, statement) ::=<<
while <parExpression>:
    <statement>
>> 

methodDeclarationSemiColon(mod, typeParameters, type, i, formalParameters, block) ::=<<
def <i>(<formalParameters>):
    <block>
>>

classBodyDeclarationMemberDecl(memberDecl) ::=<<
<memberDecl>
>> 

classBody(cbd) ::=<<
<cbd; separator="\n">
>> 

normalClassDeclaration(mod, i, params, type, typeList, block) ::=<<
class <i>:
    <block>
>> 

compilationUnit(annotations, packageDeclaration, importDeclaration, typeDeclaration) ::=<<
<annotations>
<importDeclaration>
<typeDeclaration>
>>

assign() ::=<<
=
>>

addAssign() ::=<<
+=
>>

subAssign() ::=<<
-=
>>
expressionList(expression, es) ::=<<
<expression><es; separator="\n">
>>

arguments(expressionList) ::=<<
<expressionList>
>>

print(i) ::=<<
print(<i>)
>>

variableDeclarator(i, variableInitializer) ::=<<
<i> = <variableInitializer>
>> 
localVariableDeclaration(variableModifiers, type, variableDeclarator) ::=<<
<variableDeclarator>
>>

localVariableDeclarationStatement(localVariableDeclaration) ::=<<
<localVariableDeclaration>
>> 

doStatement(statement, parExpression) ::=<<
while True:
    <statement>
    if <parExpression>:
        continue
    else:
        break
>>

caseLabel(expression) ::=<<
elif <expression>
>> 

breakStatement(i) ::=<<
break <i>
>>

switchBlockStatementGroup(switchLabel, bs) ::=<<
<switchLabel>:
    <bs; separator="\n">
>> 

switchBlockStatementGroups(s) ::=<<
<s; separator="\n">
>>

switchStatement(parExpression, switchBlockStatementGroups) ::=<<
if <parExpression>:
    <switchBlockStatementGroups>
>> 

normalForLoop(forInit, expression, expressionList, statement) ::=<<
<forInit>
while <expression>:
    <statement>
    <expressionList>

>>